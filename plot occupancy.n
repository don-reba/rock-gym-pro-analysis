// REFERENCE: Newtonsoft.Json.dll
// REFERENCE: NodaTime.dll

using Nemerle.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using NodaTime;
using System;
using System.Collections.Generic;
using System.Console;
using System.Drawing;
using System.IO;

enum Status
{
| NA
| Full
| Open
}

def CollectTimelines(minutesPerSlot, path)
{
	def timePattern = Text.LocalDateTimePattern.CreateWithCurrentCulture("yyyy-MM-dd HH:mm");
	def ParseJsonTime(str)
	{
		timePattern.Parse(str).Value
	}

	def Available(from : LocalDateTime)
	{
		from - Period.FromDays(7) - Period.FromMinutes(1);
	}

	def beginSample = ParseJsonTime("2021-03-11 19:00");
	def endSample   = ParseJsonTime("2021-03-18 19:00");

	def beginSlot = ParseJsonTime("2021-03-18 19:00");
	def endSlot   = ParseJsonTime("2021-03-25 19:00");

	def SlotIndex(from, to)
	{
		def tz = DateTimeZoneProviders.Bcl["Pacific Standard Time"];
		def from = from.InZoneStrictly(tz);
		def to   = to.InZoneStrictly(tz);
		((to - from).TotalMinutes :> int) / minutesPerSlot;
	}
	def n = SlotIndex(beginSample, endSample);

	WriteLine("Reading data...");

	def data = path |> File.ReadAllText |> JObject.Parse;

	WriteLine("Assembling timelines...");

	def timelines = List();

	foreach ((Key = slot, Value = samples) in data)
	{
		def from = ParseJsonTime(slot);
		when (from >= beginSlot && from < endSlot)
		{
			def timeline = array(n);
			foreach (sample in samples)
			{
				def i = SlotIndex(Available(from), ParseJsonTime(sample[0] :> string));
				when (i < n)
				{
					match (sample[1] :> string)
					{
					| "open" => timeline[i] = Status.Open
					| "full" when timeline[i] == Status.NA => timeline[i] = Status.Full
					| _ => ()
					}
				}
			}
			timelines.Add(slot, timeline);
		}
	}

	timelines;
}

def PlotTimelines(timelines, rowHeight, path)
{
	WriteLine("Plotting timelines...");

	def StatusColor(_ : Status)
	{
	| NA   => Color.Silver
	| Open => Color.Black
	| Full => Color.White
	}

	using (bmp = Bitmap(timelines[0][1].Length, timelines.Count * rowHeight))
	{
		foreach ((_, timeline) in timelines with n)
		{
      for (mutable x = 0; x != timeline.Length; ++x)
      {
        // vertical bars
        def color = StatusColor(timeline[x]);
        for (mutable dy = 0; dy != rowHeight; ++dy)
          bmp.SetPixel(x, n * rowHeight + dy, color);
        // horizontal lines
        when (timeline[x] == Status.Full)
          bmp.SetPixel(x, n * rowHeight + rowHeight / 2, Color.WhiteSmoke);
      }
		}
		bmp.Save(path);
	}
}

PlotTimelines
	( timelines = CollectTimelines
		( minutesPerSlot = 5
		, path           = @"analysis\combined.json"
		)
	, rowHeight = 7
	, path      = @"analysis\timelines.png"
	);
